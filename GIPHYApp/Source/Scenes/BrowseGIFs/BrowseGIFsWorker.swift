//
//  BrowseGIFsWorker.swift
//  GIPHYApp
//
//  Created by Daniel Ilchishyn on 11/2/17.
//  Copyright (c) 2017 KRUBERLICK. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import RxSwift
import RxCocoa
import Alamofire

class BrowseGIFsWorker {
    private let localStore: GIFsStoreProtocol
    private let webService: GIPHYAPIServiceProtocol
    private let localURLProvider: LocalURLProvider
    private let gifUpdatesBroadcast: GIFUpdatesBroadcast
    let contents = Variable<[GIF]>([])
    var query: String = ""
    private var disposeBag = DisposeBag()
    private var gifUpdatesBroadcastDisposeBag = DisposeBag()
    private var currentOffset = 0
    private var currentLimit = 20
    private var totalCount = 0
    private var fetchInProgress = false

    init(localStore: GIFsStoreProtocol, webService: GIPHYAPIServiceProtocol, localURLProvider: LocalURLProvider, gifUpdatesBroadcast: GIFUpdatesBroadcast) {
        self.localStore = localStore
        self.webService = webService
        self.localURLProvider = localURLProvider
        self.gifUpdatesBroadcast = gifUpdatesBroadcast
        self.gifUpdatesBroadcast.updates
            .subscribe(onNext: { [weak self] gif in
                guard let strongSelf = self else {
                    return
                }
                if let index = strongSelf.contents.value.index(of: gif) {
                    strongSelf.contents.value[index] = gif
                }
                _ = strongSelf.localStore.updateGIF(gif).subscribe()
            })
            .disposed(by: gifUpdatesBroadcastDisposeBag)
    }

    func reloadFeed() {
        currentOffset = 0
        if query.isEmpty {
            localStore.fetchGIFs()
                .subscribe(onNext: { [weak self] results in
                    self?.contents.value = results
                })
                .disposed(by: disposeBag)
        }
        else {
            _requestNextChunk(shouldReplaceContents: true)
        }
    }

    func requestNextChunk() {
        guard currentOffset < totalCount else {
            return
        }
        _requestNextChunk(shouldReplaceContents: false)
    }

    private func _requestNextChunk(shouldReplaceContents: Bool) {
        guard shouldReplaceContents || !fetchInProgress else {
            return
        }
        fetchInProgress = true
        disposeBag = DisposeBag()
        webService.searchGIFs(withQuery: query, limit: currentLimit, offset: currentOffset)
            .subscribe(onNext: { [weak self] response in
                guard let strongSelf = self else {
                    return
                }
                strongSelf.totalCount = response.pagination.totalCount
                strongSelf.currentOffset += strongSelf.currentLimit
                let gifs = response.data.map { GIF(id: $0.id, url: $0.url, localGIFData: $0.localGIFData, query: strongSelf.query) }
                if shouldReplaceContents {
                    _ = strongSelf.localStore.deleteGIFs(withQuery: strongSelf.query).subscribe()
                    strongSelf.contents.value = gifs
                }
                else {
                    strongSelf.contents.value += gifs
                }
                for gif in gifs {
                    _ = strongSelf.localStore.addGIF(gif).subscribe()
                }
                strongSelf.fetchInProgress = false
            }, onError: { [weak self] error in
                guard let strongSelf = self else {
                    return
                }
                strongSelf.localStore.fetchGIFs(withQuery: strongSelf.query)
                    .subscribe(onNext: { [weak self] gifs in
                        guard let strongSelf = self else {
                            return
                        }
                        strongSelf.contents.value = gifs
                        strongSelf.fetchInProgress = false
                    }, onError: { [weak self] error in
                        print("Error during fetch: \(error)")
                        self?.fetchInProgress = false
                    })
                    .disposed(by: strongSelf.disposeBag)
            })
            .disposed(by: disposeBag)
    }
}
